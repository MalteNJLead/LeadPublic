--[[
    Common functions to use while writing scripts for the AUBO robot.
    Created by Lead Robotics - MNJ
    To include library in your script add it to the package path and use the lua 'require' keyword. Ie input the two lines:
        package.path = package.path .. ";/root/AuboRobotWorkSpace/teachpendant/share/teachpendant/script/?.aubo"
        require("commonLib")
    The path assume the library is saved in the 'script' folder on the robot. If it is in an alternate location adjust the path accordingly. 

    Section overview: 
    1. Assorted function
    2. Table manipulation
    3. Binary Number manipulation
    4. 2DWaypoint logic
    5. Modbus communication 
    6. Movement
    7. NodeProject
    8. Matrix multiplication
]]

print("\nLoading commonLib.aubo \n") --affirmation that library loaded correctly.


------------------------------------  Section 1 - Assorted  ----------------------------------------------

function getCurrentJoints()
    local waypoint = get_current_waypoint()["joint"]
    return {waypoint["j1"], waypoint["j2"], waypoint["j3"], waypoint["j4"], waypoint["j5"], waypoint["j6"]}
end

function sign(number)
    return number > 0 and 1 or (number == 0 and 0 or -1)
end

function fileExists(path)
    local f = io.open(path, "rb")
    if f then f:close() end
    return f ~= nil
end

function checkPose(pose, dist)
    --returns true if the robots current pose is close to the given pose parameter.
    dist = dist or 0.1
    local currentPose = get_current_waypoint().joint
	currentPose = {currentPose["j1"], currentPose["j2"], currentPose["j3"], currentPose["j4"], currentPose["j5"], currentPose["j6"],}
	if euclideanDistance(currentPose, pose) >= dist then
        return false
    else
        return true
	end
end

function checkPose2(pose, dist, offset, tool) --returns true if the robots current pose is close to the given pose parameter.
    --In development to account for offsets. 
    offset = offset or {{0,0,0}, {1,0,0,0}, "flange"} -- Adjust the given pose with an offset.
    tool = tool or {kin = {{0,0,0},{1,0,0,0}}, dyn = {0, {0,0,0}}}
    dist = dist or 0.1      -- if you pass an offset you must also pass the distance.
    local currentPose = get_current_waypoint().joint
	currentPose = {currentPose["j1"], currentPose["j2"], currentPose["j3"], currentPose["j4"], currentPose["j5"], currentPose["j6"],}

    local toolPos = tool["kin"][1]
    local toolOri = tool["kin"][2]
    local posCurrent = base_to_user(pose, toolKin, toolOri)


	if euclideanDistance(currentPose, pose) >= dist then
        return false
    else
        return true
	end
end

function checkTCPToPositionProximity(newPosition, dist, tool)
    -- compares given cartesian position with the current TCP of robot and returns true if they are within dist of each other
    local jointCurrent = getCurrentJoints()
    local toolPos = gTools[tool]["pos"]
    local toolOri = gTools[tool]["ori"]
    local posCurrent = base_to_user(jointCurrent, toolPos, toolOri)
    return (euclideanDistance(newPosition, posCurrent) < dist)
end

function replaceChar(pos, str, r) -- replace character at position: pos, in string: str, with character: r.
    return str:sub(1, pos-1) .. r .. str:sub(pos+1)
end

----------------------------  Section 2 - Table Manipulation  ------------------------------

function euclideanDistance(table1, table2)
    local d = 0
    for i=1, tablelength(table1) do
        d = d + (table2[i] - table1[i])^2
    end
    return math.sqrt(d)
end

function tablelength(T)
    local count = 0
    for _ in pairs(T) do count = count + 1 end
    return count
end

function hasValue(table, value)
    for i = 1, #table do
        if value == table[i] then
            return i
        end
    end
    return false
end

function printTable(table , level)
    local key = ""
    if (#table == 0) then
        return
    end
    level = level or 1
    local indent = ""
    for i = 1, level do
        indent = indent.." "
    end
    if key ~= "" then 
        print(indent..key.." ".."=".." ".."{")
    else
        print(indent .. "{")
    end
    key = ""
    for k,v in pairs(table) do
        if type(v) == "table" then
            key = k 
            printTable(v, level + 1)
        else
            local content = string.format("%s%s = %s", indent .. " ",tostring(k), tostring(v))
            print(content)
        end
    end
    print(indent .. "}")
end

function deepCopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[deepCopy(orig_key)] = deepCopy(orig_value)
        end
        setmetatable(copy, deepCopy(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

function Set(list)
    local set = {}
    for _, l in ipairs(list) do
        set[l] = true
    end
    return set
end

function dot(point1, point2)
    if not (#point1 == #point2) then
        popup_message(0, "Error. Points are of different length in dot", false)
    end
    local sum = 0
    for i = 1, #point1 do
        sum = sum + point1[i]*point2[i]
    end
    return sum
end

function vectorAdd(vec1, vec2)
    if (not (#vec1 == #vec2)) then
        popup_message(0, "Error. Vectors are of different length in vectorAdd", false)
    end
    local vec3 = {}
    for i=1, #vec1 do
        table.insert(vec3, vec1[i]+vec2[i])
    end
    return vec3
end


-----------------------------  Section 3 - Binary number manipulation  --------------------------------------

function getBit(n, pos) -- get bit of decimal number n, at position pos. 0 index'ed.
    local str = Dec2Bin(n, 16)
    return tonumber(string.sub(str, -(1 + pos), -(1 + pos)))
end

function setBit(pos, n, r)-- returns decimal number, n, with bit at position pos set to value r. 0 index'ed.
    r = tostring(r)
    if not (r == "0" or r == "1") then
        print("Error. Unable to set Bit")
        return n
    end
    local currentBit = tostring(getBit(n, pos))
    if (currentBit == "0") and (r == "1") then
        return n + 2^pos
    elseif (currentBit == "1") and (r == "0") then
        return n - 2^pos
    else
        return n
    end
end

function Bin2Dec(s) -- binary string
    local num = 0
    local ex = string.len(s) - 1
    local l = 0
    l = ex + 1
    for i = 1, l do
        b = string.sub(s, i, i)
        if b == "1" then
            num = num + 2^ex
        end
        ex = ex - 1
    end
    return string.format("%u", num)
end

function Hex2Bin(s)
    -- convert number written in Hexadecimal as a string to a string writtten in binary. 
    local hex2bin = {
        ["0"] = "0000",
        ["1"] = "0001",
        ["2"] = "0010",
        ["3"] = "0011",
        ["4"] = "0100",
        ["5"] = "0101",
        ["6"] = "0110",
        ["7"] = "0111",
        ["8"] = "1000",
        ["9"] = "1001",
        ["a"] = "1010",
        ["b"] = "1011",
        ["c"] = "1100",
        ["d"] = "1101",
        ["e"] = "1110",
        ["f"] = "1111"
        }
    string.gfind = string.gfind or string.gmatch
    local ret = ""
    local i = 0
    for i in string.gfind(s, ".") do
        i = string.lower(i)
        ret = ret..hex2bin[i]
    end
    return ret
end

function Bin2Hex(s)
    -- convert string binary number to string hexadecimal number 
    local l = 0
    local h = ""
    local b = ""
    local rem
    l = string.len(s)
    rem = l % 4
    l = l-1
    h = ""
    -- need to prepend zeros to eliminate mod 4
    if (rem > 0) then
        s = string.rep("0", 4 - rem)..s
    end
    for i = 1, l, 4 do
        b = string.sub(s, i, i+3)
        h = h..bin2hex[b]
    end
    return h
end

function Dec2Bin(s, num)
    -- convert decimal number to a binary string. num: string length to extend to
    local n
    if (num == nil) then
        n = 0
    else
        n = num
    end
    s = string.format("%x", s)
    s = Hex2Bin(s)
    while string.len(s) < n do
        s = "0"..s
    end
    return s
end


------------------------------------- Section 4 - 2DWaypoint logic ------------------------

function addIntermediaryPoints(waypoint1, waypoint2, resolution)
    local xDiff = waypoint2[1] - waypoint1[1]
    local yDiff = waypoint2[2] - waypoint1[2]
    local zDiff = euclideanDistance(waypoint1, waypoint2)
    local nrOfSegments = math.ceil(zDiff/resolution)
    local xIncrement = xDiff/nrOfSegments
    local slope = yDiff / xDiff
    local points = {waypoint1}
    for i = 1, nrOfSegments-1 do
        local newX = waypoint1[1] + i * xIncrement
        local newY = waypoint1[2] + i * xIncrement * slope
        table.insert(points, {newX, newY})
    end
    table.insert(points, waypoint2)
    return(points)
end

function rotateWaypointAbsolute(waypoint, angle)
    -- considers origo the corner of an angle with one leg along the positive x axis and the other towards the point. 
    -- Sets the angle to be equal to the given 'angle' and returns the new position of the point. the distance between point and origo is unchanged. 
    local z = math.sqrt(waypoint[1]^2 + waypoint[2]^2)
    local y = math.sin(math.rad(angle))*z
    local x = math.cos(math.rad(angle))*z
    return {x, y}
end

function rotateWaypointRelative(waypoint, angle)
    -- considers origo the corner of an angle with one leg along the positive x axis and the other towards the point. 
    -- adds 'angle' to this angle and return the new position of the point. 
    local absoluteAngle = angle + math.deg(atan2(waypoint[2], waypoint[1]))  -- atan(modstÃ¥ende, hosliggende)
    return rotateWaypointAbsolute(waypoint, absoluteAngle)
end

function rotateWaypointsRelative(List, angle)
    newList = {}
    for i, waypoint in ipairs(List) do
        table.insert(newList, rotateWaypointRelative(waypoint, angle))
    end
    return newList
end

function extendWaypoint(point1, point2, dist)
    -- returns a point3, that is at the tip of a vector with length dist, that lies on the line intersecting point1 and point2.
    -- The vector starts at point 2 and extends in the direction away from point 1.
    local xDiff = point2[1] - point1[1]
    local yDiff = point2[2] - point1[2]
    if xDiff^2+yDiff^2 == 0 then
        popup_message(0, "Extend waypoint failed. Same point." .. setting, false)
        return
    end
    local coef = math.sqrt(dist^2/(xDiff^2+yDiff^2))
    return {point2[1] + xDiff*coef, point2[2] + yDiff*coef}
end


------------------------------  Section 5 - Modbus Communication  -------------------------------------------------

function getValueModbus(register)
    --Returns signed values unlike get_modbus_io_status(register)
    local rawValue = get_modbus_io_status(register)
    if rawValue >= 2^15 then
        local flip = -(2^16 - rawValue)
        return flip
    else
        return rawValue
    end
end

function getModbusBit(register, bit)
    -- Get single bit at position, bit, from modbusregister, register.
    local rawValue = get_modbus_io_status(register)
    return getBit(rawValue, bit)
end

function setModbusBit(register, bit, value, verbose)
    -- Set single bit at position bit in register.
    local rawValue = get_modbus_io_status(register)
    local bin = Dec2Bin(rawValue, 16)
    local pos = 16 - bit
    if value == 0 then
        local writeValue = replaceChar(pos, bin, '0')
        writeValue = tonumber(Bin2Dec(writeValue))
        setValueModbus(register, writeValue, verbose)
    elseif value == 1 then
        local writeValue = replaceChar(pos, bin, '1')
	    writeValue = tonumber(Bin2Dec(writeValue))
        setValueModbus(register, writeValue, verbose)
    else
        popup_message(0, "Error. Invalid bitvalue in setModbusBit", false)
    end
end

function setValueModbus(register, value, verbose)
    -- Set modbus register and check that it has been set by reading it back.
    if verbose then
	    print("Modbus. Writing value " .. tostring(value) .. " To channel " ..register)
    end
    if value < 0 then
        value = 2^16 + value
    end
	set_modbus_io_status(register, value)
	for i=1, 5 do
 		if (get_modbus_io_status(register)==value) then
			return 1
		end
		sleep(0.005)
	end
	set_modbus_io_status(register, value)
	for i=1, 5 do
 		if (get_modbus_io_status(register)==value) then 
			return 1
		end
		sleep(0.005)
	end
    print("Warning. unable to read the set modbus value in SetValueModbus. Set value: "
     .. tostring(value) .. " Read value: " .. tostring(get_modbus_io_status(register)))
	return -1
end


------------------------------ Section 6 - Movement ----------------------------

function setSpeed(setting)
    -- sets speeed of the robot using settings from gSpeedSettings
    local speed = gSpeedSettings[setting]
    set_joint_maxacc(speed["jointAcc"])   -- joint 1,2,3,4,5,6. Acceleration is given in rad/s^2.
    set_joint_maxvelc(speed["jointVel"]) -- joint 1,2,3,4,5,6. In rad/s. Maximum is 1 rad/s (joint3 is 0.83 rad/s)
    set_end_maxacc(speed["TCPAcc"]) -- in m/s^2
    set_end_maxvelc(speed["TCPVel"])
end

function moveJoint(joint, block, speed)
    if speed then
        setSpeed(speed)
    end
    move_joint(joint, block)
end

function moveLine(joint, block, speed)
    if speed then
        setSpeed(speed)
    end
    move_line(joint, block)
end

function move(joint, type, speed, block)
    if speed then
        setSpeed(speed)
    end
    if (block == nil) then -- If block parameter is not given set it to true. 
        block = true
    end
    gIsMoving = true
    if type == "joint" then
        moveJoint(joint, block, speed)
    elseif type == "line" then
        moveLine(joint, block, speed)
    else
        popup_message(0, "Error. Unknown move parameter", false)
    end
    gIsMoving = false
end

function moveRunup(endPose, runupAcc, runupAirtime, startActionFunction, endActionFuntion, speed, tool)
    -- Intended for use in spraypainting. will move to 'endPose' and call the startActionFunction after moving the runuptime. 
    -- If the runup is set accurately the painted section on the cancas should be centered between the start and endpose.
    -- There will still be a gap between the startpose and the painted section depending on the size of the runup. 
    tool = tool or "flange"                 -- Default paramter for the tool is "flange"
    speed = speed or "slow"                 -- Default speed i slow.

    local startPose = getCurrentJoints()      -- StartPose is the currentPose.
    local toolKin = gTools[tool]["pos"]  -- Extract tool kinematics for clarity
    local toolOri = gTools[tool]["ori"]
    local startPosition, startRotation = base_to_user(startPose, toolKin, toolOri)  -- convert the poses to a position of the TCP 
    local endPosition, endRotation = base_to_user(endPose, toolKin, toolOri)
    local startRunUp = runupAcc     -- inserting runup to achieve full velocity. The airtime of the paint wil further delay when the paint hits the canvas. 
    local endRunUp = runupAcc + runupAirtime + runupAirtime -- first runupAirtime should put tcp level with the end of the stripe. The second airtime and the acceleration makes sure the stripe is centered.  
    move(startPose, "joint", "medium", true)    -- moveJoint to start position. 
    move(endPose, "line", speed, false)         -- moveLine for the painting. Notice that the 'block' parameter is set to false so we can keep executing the program. 
    while checkTCPToPositionProximity(startPosition, startRunUp, tool) do -- Repeatedly check if we have moved futher than the startRunup. 
        sleep(0.001)
    end
    startActionFunction() -- Run the parametergiven function. This could fx be where you activate a sprayGun for painting.  
    while not checkTCPToPositionProximity(endPosition, endRunUp, tool) do   --Repeatedly check when we are close enough to the endpoint depending on the endRunup. 
        sleep(0.001)
    end
    endActionFuntion()      -- Run the other parametergivenFunction. Fx a stop function for a sprayGun. 
    while not checkTCPToPositionProximity(endPosition, 0.001, tool) do -- check when we have arrived at the endPosition
        sleep(0.001)
    end
    sleep(0.8)  -- The robot will return an error if a movecommmand is given before the movement is completely done. Therefore a delay is put in. 
end


------------------------------ Section 7 - NodeProject ----------------------------

--[[
    Use of node system. 
    Requires globalvariables:
    - gNodes. Included from other file dict with the information about each node in the tree. 
    - gCurrentNode. Which holds the name for current Node ie. its key to the gNodes dict.
    - gTools. List of toolSettings.
    - gCurrentTool. Integer that indicates different toolsettings. A Connection between nodes can be limited to only allow certain tools.  
    - gSimulation. Optional. If true movement is not performed. gCurrentNode is still changed to match target endNode.
    ]]



function checkIfAtIdle()
    -- Since the program does not know where the robot is when it starts a check should be made to put the robot in the Nodesystem. 
    local idlePose = gNodes["idle"][1]
    return checkPose(idlePose)

end

function setRobotInIdleNode()
    if checkIfAtIdle() then
        gCurrentNode = "idle"
        return true
    else
        popup_message(0, "Robot not at idle node ensureCorrectStartPosition", false)
        return false
    end
end

function setOffset(offsetName)
    -- Sets a relative offset from gOffsets. If no tool is defined in the offset then the base frame will be used as reference. 
    print("Setting offset: " .. offsetName)
    local offset = gOffsets[offsetName]["pos"]
    local rotation = gOffsets[offsetName]["ori"]
    if (#gOffsets[offsetName] > 2) then
        local toolName = gOffsets[offsetName]["tool"]
        local toolPos = gTools[toolName]["pos"]
        local toolOri = gTools[toolName]["ori"]
        set_relative_offset(offset, rotation, toolPos, toolOri)
        return
    end
    set_relative_offset(offset, rotation)
end

function checkConnectionValid(connection)
    -- checks if a node reference exist and has a valid tool reference. 
	if (gNodes[connection["node"]] == nil) then
		popup_message(0, "Error. Unknown node reference, " .. tostring(connection["node"]) .. ",  in searchTree", false)
	end
	for i = 1, #connection["tools"] do
		if (gTools[connection["tools"][i]] == nil) then
			popup_message(0, "Error. Unknown tool reference, " .. tostring(connection["tools"][i]) .. ", in searchTree", false)
		end
	end
end

function searchTree(target)
    -- searches through the tree defined in gNodes to find a movement path to the node with keystring 'target'
	print("searching for target node: " .. tostring(target))
    if target == gCurrentNode then
        print("SearchTree warning: Already at position.")
        return "alreadyAtPosition"
    end
	if (gNodes[target] == nil) then
		popup_message(0, "Error. Unknown target position in searchTree", false)
		return
	end
    local queue = {} -- ordered queue of connections to move through
    local nodeName, connection, toolOptions, knownNodes
    for i, currentConnection in ipairs(gNodes[gCurrentNode]["connections"]) do
        if (hasValue(currentConnection["tools"], gCurrentTool)) then
            checkConnectionValid(currentConnection)
            table.insert(queue, currentConnection)
		end
    end
    if next(queue) == nil then
        popup_message(0, "Error. No path found from current node: " .. tostring(gCurrentNode) .. " with tool: " .. tostring(gCurrentTool), false)
    end
    local previousVisits = {gCurrentNode}
    while not (queue[1][#queue[1]][1] == target) do -- If last node of the connection matches the target we have found a valid connection.
        nodeName = queue[1][#queue[1]][1]
        knownNodes = Set(previousVisits)
        if (not knownNodes[nodeName]) then
            --print("nodeName: " .. nodeName)
            for i, currentPath in ipairs(gNodes[nodeName][2]) do
			checkConnectionValid(currentPath)
                toolOptions = Set(currentPath[4])
                if (toolOptions[gCurrentTool]) then
                    connection = {}
                    connection = deepCopy(queue[1])
                    table.insert(connection, {currentPath[1], currentPath[2], currentPath[3]}) --create connection with additional node.
                    table.insert(queue, deepCopy(connection)) -- insert amended path at the back of the queue.
                end
            end
        end
        table.remove(queue, 1) --remove the path we were looking at
        table.insert(previousVisits, nodeName)
		local next = next
        if next(queue) == nil then
            popup_message(0, "Error. No path found in searchTree from " .. gCurrentNode .. " to " .. target, false)
        end
    end
    print("Found path to " .. target)
    printTable(queue[1])
    return deepCopy(queue[1]) -- return the path in format {{nodeName1, movetype1, speed1}, {nodeName2, movetype2, speed2}, ...}
end

function resetPoseLog()
    -- reset the file where path movement is logged
    local filePathLog = "/root/AuboRobotWorkSpace/teachpendant/share/teachpendant/script/PositionsLog.aubo"
    fileLog = io.open(filePathLog, 'w')
    fileLog:write("start\n")
    fileLog:close()
end

function savePose(name)
    -- Save status of current position and the current node in a path in a logfile.
    local filepath = "/root/AuboRobotWorkSpace/teachpendant/share/teachpendant/script/PositionsLog.aubo"
    file = io.open(filepath, 'a')
    local waypoint = get_current_waypoint()
    local currentPose = waypoint.joint
    local currentPos = waypoint.pos
    local str = tostring(name) .. " -> \nFixedJoints("
    str = str .. (tostring(gNodes[name][1][1]) .. ", "..
    tostring(gNodes[name][1][2]) .. ", "..
    tostring(gNodes[name][1][3]) .. ", "..
    tostring(gNodes[name][1][4]) .. ", "..
    tostring(gNodes[name][1][5]) .. ", "..
    tostring(gNodes[name][1][6]))
    str = str .. ")\nActualJoints("
    str = str .. (tostring(currentPose["j1"]) .. ", "..
        tostring(currentPose["j2"]) .. ", "..
        tostring(currentPose["j3"]) .. ", "..
        tostring(currentPose["j4"]) .. ", "..
        tostring(currentPose["j5"]) .. ", "..
        tostring(currentPose["j6"]))
    str = str .. ")\nActualPose(" .. currentPos["x"] .. ", ".. currentPos["y"] .. ", ".. currentPos["z"]
    str = str .. ")\n"
    file:write(str)
    file:close()
end

function movePath(endNode, onEachMove)
    --move along path defined in gNodes to node with key: 'endNode'. Execute the function onEachMove before each move.
    if gSimulation then
        gCurrentNode = gNodes[endNode][1]
        return
    end
	local currentNodePose = gNodes[gCurrentNode][1]
    --[[Midlertidigt suspenderet ventende pÃ¥ en udvidning af checkpose sÃ¥ den medregner et offset. 
    if not checkPose(currentNodePose, 0.2) then
        popup_message(0, "Error. Robot not at currentNode pose in movePath", false)
        return
    end
    ]]
    local path = searchTree(endNode)
    if path == "alreadyAtPosition" then
        return
    end
    for i, node in ipairs(path) do
        print("Moving " .. node[2] .. "wise to " .. node[1] .." with speed " .. node[3])
	    init_global_move_profile()
        if onEachMove~= nil and onEachMove() == "cancel" then
            return "cancel"
        end
        if (gNodes[node[1]][1] == "variable") or (gNodes[node[1]][1] == nil) then
            popup_message(0, "Error. No pose found for node: " .. node[1] .. " in movePath.", false)
        end
        if gNodes[node[1]][3] == "none" then
            move(gNodes[node[1]][1], node[2], node[3], true)
            savePose(node[1])
        elseif gOffsets[gNodes[node[1]][3]] == nil then
			popup_message(0, "Error. No offfset reference found in movePath", false)
		else
            setOffset(gNodes[node[1]][3])
            move(gNodes[node[1]][1], node[2], node[3], true)
            savePose(node[1])
            init_global_move_profile()
        end
        gCurrentNode = node[1]
    end
end


---------------- section 8 - Matrix Manipulation and rotation -------------------


function checkMatrix(mat) -- returns true if matrix is valid.
    if next(mat) == nil then
        popup_message(0, "Error. Matrix empty in checkMatrix")
    end
    for i = 1, #mat do
        if (next(mat[i]) == nil) then
            popup_message(0, "Error. Matrix row empty in checkMatrix")
        end
        if (not (#mat[i] == #mat[1])) then
            return popup_message(0, "Error. Matrix invalid in checkMatrix", false)
        end
    end
end

function getColoumnOfMatrix(mat, coloumn)
    checkMatrix(mat)
    coloumn = coloumn or 1
    local coloumnList = {}
    for i = 1, #mat do
        table.insert(coloumnList, mat[i][coloumn])
    end
    return coloumnList
end

function rowToColoumn(vector)
    local newMat = {}
    for i=1, #vector do
        table.insert(newMat, {vector[i]})
    end
    return newMat
end

function matrixMultiply(mat1, mat2)
    checkMatrix(mat1)
    checkMatrix(mat2)
    if not (#mat1[1] == #mat2) then
        popup_message(0, "Error. Matrices incompatible in matrixMultiply", false)
    end
    local result = {}
    local resultRow = {}
    for i = 1, #mat1[1] do
        for j = 1, #mat2[1] do
            local mat2Coloumn = getColoumnOfMatrix(mat2, j)
            table.insert(resultRow, dot(mat1[i], mat2Coloumn))
        end
        table.insert(result, resultRow)
        resultRow = {}
    end
    return result
end

function rotatePointAboutAxis(point, axis, angle) -- point in {x,y,z} format, axis is a string: "x", "y" or "z", angle is measured in radians
    local newPoint
    if #point == 3 then
        local coloumnPoint = rowToColoumn(point)
        local rotationMatrix = {}
        if axis == "x" then
            rotationMatrix = {
                {1,0,0},
                {0, math.cos(angle), -math.sin(angle)},
                {0, math.sin(angle), math.cos(angle)}
            }
        elseif axis == "y" then
            rotationMatrix = {
                {math.cos(angle),0,math.sin(angle)},
                {0, 1, 0},
                {-math.sin(angle), 0, math.cos(angle)}
            }
        elseif axis == "z" then
            rotationMatrix = {
                {math.cos(angle),-math.sin(angle), 0},
                {math.sin(angle), math.cos(angle), 0},
                {0, 0, 1}
            }
        end
        newPoint = matrixMultiply(rotationMatrix, coloumnPoint)
        newPoint = getColoumnOfMatrix(newPoint, 1)
    else
        popup_message(0, "Error. Wrong length of point in rotatePointAboutAxis", false)
    end
    return newPoint
end
