--[[
    Common functions to use while writing scripts for the AUBO robot.
    Created by Lead Robotics - MNJ
]]


------------------------------------  Section 1 - Assorted  ----------------------------------------------

function fileExists(file)
    local f = io.open(file, "rb")
    if f then f:close() end
    return f ~= nil
end

function checkPose(pose, dist) --returns true if the robots current pose is close to the given pose parameter.
    local currentPose = get_current_waypoint().joint
    dist = dist or 0.1
	currentPose = {currentPose["j1"], currentPose["j2"], currentPose["j3"], currentPose["j4"], currentPose["j5"], currentPose["j6"],}
	if euclideanDistance(currentPose, pose) >= dist then
        return false
    else
        return true
	end
end

function waypointCompare(a,b)
    return a[1] < b[1]
end

function replaceChar(pos, str, r)
    return str:sub(1, pos-1) .. r .. str:sub(pos+1)
end

----------------------------  Section 2 - Table Manipulation  ------------------------------

function euclideanDistance(table1, table2)
    local d = 0
    for i=1, tablelength(table1) do
        d = d + (table2[i] - table1[i])^2
    end
    return math.sqrt(d)
end


function tablelength(T)
    local count = 0
    for _ in pairs(T) do count = count + 1 end
    return count
end

function hasValue(table, value)
    for i = 1, #table do
        if value == table[i] then
            return i
        end
    end
    return false
end

function printTable(table , level)
    local key = ""
    if (#table == 0) then
        return
    end
    level = level or 1
    local indent = ""
    for i = 1, level do
        indent = indent.." "
    end
    if key ~= "" then 
        print(indent..key.." ".."=".." ".."{")
    else
        print(indent .. "{")
    end
    key = ""
    for k,v in pairs(table) do
        if type(v) == "table" then
            key = k 
            printTable(v, level + 1)
        else
            local content = string.format("%s%s = %s", indent .. " ",tostring(k), tostring(v))
            print(content)
        end
    end
    print(indent .. "}")
end

function deepCopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[deepCopy(orig_key)] = deepCopy(orig_value)
        end
        setmetatable(copy, deepCopy(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

function Set (list)
    local set = {}
    for _, l in ipairs(list) do set[l] = true end
    return set
end


-----------------------------  Section 2 - Binary number manipulation  --------------------------------------

function getBit(n, pos) -- get bit of decimal number n, at position pos. 0 index'ed.
    local str = Dec2Bin(n, 16)
    return tonumber(string.sub(str, -(1 + pos), -(1 + pos)))
end

function setBit(pos, n, r)-- returns decimal number, n, with bit at position pos set to value r. 0 index'ed.
    r = tostring(r)
    if not (r == "0" or r == "1") then
        print("Error. Unable to set Bit")
        return n
    end
    local currentBit = tostring(getBit(n, pos))
    if (currentBit == "0") and (r == "1") then
        return n + 2^pos
    elseif (currentBit == "1") and (r == "0") then
        return n - 2^pos
    else
        return n
    end
end

function Bin2Dec(s) -- binary string
    local num = 0
    local ex = string.len(s) - 1
    local l = 0
    l = ex + 1
    for i = 1, l do
        b = string.sub(s, i, i)
        if b == "1" then
            num = num + 2^ex
        end
        ex = ex - 1
    end
    return string.format("%u", num)
end

function Hex2Bin(s) -- s	-> hexadecimal string
    local hex2bin = {
        ["0"] = "0000",
        ["1"] = "0001",
        ["2"] = "0010",
        ["3"] = "0011",
        ["4"] = "0100",
        ["5"] = "0101",
        ["6"] = "0110",
        ["7"] = "0111",
        ["8"] = "1000",
        ["9"] = "1001",
        ["a"] = "1010",
        ["b"] = "1011",
        ["c"] = "1100",
        ["d"] = "1101",
        ["e"] = "1110",
        ["f"] = "1111"
        }
    string.gfind = string.gfind or string.gmatch
    local ret = ""
    local i = 0
    for i in string.gfind(s, ".") do
        i = string.lower(i)
        ret = ret..hex2bin[i]
    end
    return ret
end

function Bin2Hex(s)
    -- s 	-> binary string
    local l = 0
    local h = ""
    local b = ""
    local rem
    l = string.len(s)
    rem = l % 4
    l = l-1
    h = ""
    -- need to prepend zeros to eliminate mod 4
    if (rem > 0) then
        s = string.rep("0", 4 - rem)..s
    end
    for i = 1, l, 4 do
        b = string.sub(s, i, i+3)
        h = h..bin2hex[b]
    end
    return h
end

function Dec2Bin(s, num) -- Base10 string -- num  -> string length to extend to
    local n
    if (num == nil) then
        n = 0
    else
        n = num
    end
    s = string.format("%x", s)
    s = Hex2Bin(s)
    while string.len(s) < n do
        s = "0"..s
    end
    return s
end


------------------------------------- Section 3 - 2DWaypoint logic ------------------------

function addIntermediaryPoints(waypoint1, waypoint2, resolution)
    local xDiff = waypoint2[1] - waypoint1[1]
    local yDiff = waypoint2[2] - waypoint1[2]
    local zDiff = euclideanDistance(waypoint1, waypoint2)
    local nrOfSegments = math.ceil(zDiff/resolution)
    local xIncrement = xDiff/nrOfSegments
    local slope = yDiff / xDiff
    local points = {waypoint1}
    for i = 1, nrOfSegments-1 do
        local newX = waypoint1[1] + i * xIncrement
        local newY = waypoint1[2] + i * xIncrement * slope
        table.insert(points, {newX, newY})
    end
    table.insert(points, waypoint2)
    return(points)
end

function rotateWaypointAbsolute(waypoint, angle) -- angle measured as difference from the x axis in degrees
    local z = math.sqrt(waypoint[1]^2 + waypoint[2]^2)
    local y = math.sin(math.rad(angle))*z
    local x = math.cos(math.rad(angle))*z
    return {x, y}
end

function rotateWaypointRelative(waypoint, angle)
    local absoluteAngle = angle + math.deg(atan2(waypoint[2], waypoint[1]))  -- atan(modstående, hosliggende)
    return rotateWaypointAbsolute(waypoint, absoluteAngle)
end

function rotateWaypointsRelative(List, angle)
    newList = {}
    for i, waypoint in ipairs(List) do
        table.insert(newList, rotateWaypointRelative(waypoint, angle))
    end
    return newList
end

function findRotationForWaypoints(waypoints, option) --returns a rotation at which these waypoint can be reached. Returns false if none exist.
    for degrees=0,360 do
        local currentWaypoints = rotateWaypointsRelative(waypoints, degrees)
        if checkWaypoints(currentWaypoints, option) then
            return degrees
        end
    end
    return false
end

function findStrokes(waypoints, option)
    local evaluationStrokes = {waypoints}
    local resultStrokes = {}
    local angles = {}
    for i, stroke in ipairs(evaluationStrokes) do
        local rotation = findRotationForWaypoints(stroke, option)
        if rotation == false then
            local waypointsA, waypointsB = splitWaypoints(stroke)
            table.insert(evaluationStrokes, waypointsA)
            table.insert(evaluationStrokes, waypointsB)
        else
            table.insert(resultStrokes, stroke)
            table.insert(angles, rotation)
        end
    end
    return resultStrokes, angles
 end

function splitWaypoints(waypoints) --takes a list of waypoints and splits it down the middle returning two lists.
local tableA, tableB = {}, {}
local splitpoint = math.floor(tablelength(waypoints))
    for i, waypoint in ipairs(waypoints) do
        if i <= splitpoint then
            table.insert(tableA, waypoint)
        end
        if i >= splitpoint then
            table.insert(tableB, waypoint)
        end
    end
    return tableA, tableB
end

function checkWaypoints(waypoints, option) --returns true if all waypoints are within boundary
    local n = true
    for i, waypoint in ipairs(waypoints) do
        if not checkWaypoint(waypoint, option) then
            n = false
            break
        end
    end
    return n
end

function checkWaypoint(waypoint, option) --returns true if point is within boundary, false if it is outside.
    local lines = {}
    if option == "left" then
        lines = gBoundaryLinesLeft
    elseif option == "right" then
        lines = gBoundaryLinesRight
    end
    for i, line in ipairs(lines) do 
        local d = (waypoint[1] - line[1]) * (line[4] - line[2]) - (waypoint[2] - line[2]) * (line[3] -line[1]) --if the point is on the right side of the vector d will be positive. If left it will be negative. On the line zero.
        if (d > 0) then --the sign of d indicates which side of the line we are on. If we are on the right side we are outside the boundary and d is positive. left side inside boundary error .
            return false
        end
    end
    return true
end

function getXYDiff(point1, point2)
    local xDiff = point2[1] - point1[1]
    local yDiff = point2[2] - point1[2]
    return xDiff, yDiff
end

function extendWaypoint(point1, point2, dist) -- returns a point3, that is on the line intersecting point1 and point2, but moved dist further.
    local xDiff, yDiff = getXYDiff(point1, point2)
    if xDiff^2+yDiff^2 == 0 then
        popup_message(0, "Extend waypoint failed. Same point." .. setting, false)
        return
    end
    local coef = math.sqrt(dist^2/(xDiff^2+yDiff^2))
    return {point2[1] + xDiff*coef, point2[2] + yDiff*coef}
end


------------------------------  Section 4 - Modbus Communication  -------------------------------------------------

function getValueModbus(register) --Returns signed values unlike get_modbus_io_status(register)
    local rawValue = get_modbus_io_status(register)
    if rawValue >= 2^15 then
        local flip = -(2^16 - rawValue)
        return flip
    else
        return rawValue
    end
end

function getModbusBit(register, bit)
    local rawValue = get_modbus_io_status(register)
    return getBit(rawValue, bit)
end

function setModbusBit(register, bit, value, verbose)
    local rawValue = get_modbus_io_status(register)
    local bin = Dec2Bin(rawValue, 16)
    local pos = 16 - bit
    if value == 0 then
        local writeValue = replaceChar(pos, bin, '0')
        writeValue = tonumber(Bin2Dec(writeValue))
        setValueModbus(register, writeValue, verbose)
    elseif value == 1 then
        local writeValue = replaceChar(pos, bin, '1')
	    writeValue = tonumber(Bin2Dec(writeValue))
        setValueModbus(register, writeValue, verbose)
    else
        popup_message(0, "Error. Invalid bitvalue in setModbusBit", false)
    end
end

function setValueModbus(register, value, verbose)
    if verbose then
	    print("Modbus. Writing value " .. tostring(value) .. " To channel " ..register)
    end
    if value < 0 then
        value = 2^16 + value
    end
	set_modbus_io_status(register, value)
	for i=1, 5 do
 		if (get_modbus_io_status(register)==value) then
			return 1
		end
		sleep(0.005)
	end
	set_modbus_io_status(register, value)
	for i=1, 5 do
 		if (get_modbus_io_status(register)==value) then 
			return 1
		end
		sleep(0.005)
	end
	--popup_message(0, "ERROR: Unable to set modbus value. SetValueModbus", false)
    print("Warning. unable to read the set modbus value in SetValueModbus. Set value: "
     .. tostring(value) .. " Read value: " .. tostring(get_modbus_io_status(register)))
	return -1
end


------------------------------ Section 5 - Movement ----------------------------

gIsMoving = false
gSpeedSettings = {}
gSpeedSettings["slow"] = {{0.5, 0.5, 0.5, 0.5, 0.5 ,0.5}, {0.1, 0.1, 0.1, 0.2, 0.2, 0.2}, 0.4, 0.08}
gSpeedSettings["medium"] = {{1, 1, 1, 1, 1 ,1}, {0.5, 0.5, 0.5, 0.8, 0.8, 0.8}, 2, 0.4}
gSpeedSettings["fast"] = {{4, 4, 4, 4, 4 ,4}, {2, 2, 2, 3, 3, 3}, 6, 1}

function moveJoint(joint, block, speed)
    setSpeed(speed)
    move_joint(joint, block)
end

function moveLine(joint, block, speed)
    setSpeed(speed)
    move_line(joint, block)
end

function move(joint, type, speed, block)
    setSpeed(speed)
    gIsMoving = true
    if type == "joint" then
        moveJoint(joint, block, speed)
    elseif type == "line" then
        moveLine(joint, block, speed)
    else
        popup_message(0, "Error. Unknown move parameter", false)
    end
    gIsMoving = false
end

function setSpeed(setting)
    local speed = gSpeedSettings[setting]
    set_joint_maxacc(speed[1])   -- joint 1,2,3,4,5,6. Acceleration is given in rad/s^2.
    set_joint_maxvelc(speed[2]) -- joint 1,2,3,4,5,6. In rad/s. Maximum is 1 rad/s (joint3 is 0.83 rad/s)
    set_end_maxacc(speed[3]) -- in m/s^2
    set_end_maxvelc(speed[4])
end

function checkPosition(newPosition, dist, tool) -- compares given position with the current position of robot and returns true if they are within dist of each other
    local temp = get_current_waypoint().joint
    local jointCurrent = {temp.j1, temp.j2, temp.j3, temp.j4, temp.j5, temp.j6}
    local toolKin = gTools[tool]["kin"][1]
    local toolOri = gTools[tool]["kin"][2]
    local posCurrent = base_to_user(jointCurrent, toolKin, toolOri)
    return (euclideanDistance(newPosition, posCurrent) < dist)
end

function moveRunup(endPose, runupAcc, runupAirtime, startSprayFunction, endSprayFuntion, speed, tool, startPose)
    local currentPose = get_current_waypoint().joint
    currentPose = {currentPose["j1"], currentPose["j2"], currentPose["j3"], currentPose["j4"], currentPose["j5"], currentPose["j6"]}
    startPose = startPose or currentPose
    tool = tool or "flange"
    speed = speed or "slow"
    local toolKin = gTools[tool]["kin"][1]
    local toolOri = gTools[tool]["kin"][2]

    local startPosition, startRotation = base_to_user(startPose, toolKin, toolOri)
    local endPosition, endRotation = base_to_user(endPose, toolKin, toolOri)
    local startRunUp = runupAcc
    local endRunUp = runupAcc + runupAirtime + runupAirtime
    move(startPose, "joint", "medium", true)
    move(endPose, "line", speed, false)
    while checkPosition(startPosition, startRunUp, tool) do
        sleep(0.001)
    end
    startSprayFunction()
    while not checkPosition(endPosition, endRunUp, tool) do
        sleep(0.001)
    end
    endSprayFuntion()
    while not checkPosition(endPosition, 0.001, tool) do
        sleep(0.001)
    end
    sleep(0.8) --wait for line to finish
end


------------------------------ Section 6 - NodeProject ----------------------------

--[[
    Use of node system. 
    Requires globalvariables:
    - gNodes. Included from other file dict with the information about each node in the tree. 
    - gCurrentNode. Which holds the name for current Node ie. its key to the gNodes dict.
    - gCurrentTool. Integer that indicates different toolsettings. A Connection between nodes can be limited to only allow certain tools.  
    - gSimulation. Optional. If true movement is not performed. gCurrentNode is still changed to match target endNode.
    ]]

function setOffset(offsetName)
    print("Setting offset: " .. offsetName)
    local offset = gOffsetTable[offsetName][2]
    local rotation = gOffsetTable[offsetName][3]
    local toolName = gOffsetTable[offsetName][4]
    local toolPos = gTools[toolName]["kin"][1]
    local toolOri = gTools[toolName]["kin"][2]
	set_relative_offset(offset, rotation, toolPos, toolOri)
end

function checkPathReferences(link)
	if (gNodes[link[1]] == nil) then
		popup_message(0, "Error. Unknown node reference, " .. tostring(link[1]) .. ",  in searchTree", false)
	end
	for i =1, #link[4] do
		if (gTools[link[4][i]] == nil) then
			popup_message(0, "Error. Unknown tool reference, " .. tostring(link[4][i]) .. ", in searchTree", false)
		end
	end
end

function searchTree(target)
	print("searching for target node: " .. tostring(target))
    if target == gCurrentNode then
        print("SearchTree warning: Already at position.")
        return "alreadyAtPosition"
    end
	if (gNodes[target] == nil) then
		popup_message(0, "Error. Unknown target position in searchTree", false)
		return
	end
    local queue = {}--contains list of paths
    local nodeName, path, toolOptions, knownNodes
    for i, currentPath in ipairs(gNodes[gCurrentNode][2]) do
          toolOptions = Set(currentPath[4])
          if (toolOptions[gCurrentTool]) then
			checkPathReferences(currentPath)
			table.insert(queue, {{currentPath[1], currentPath[2], currentPath[3]}})
		end
    end
    if next(queue) == nil then
        popup_message(0, "Error. No path found from current node: " .. tostring(gCurrentNode) .. " with tool: " .. tostring(gCurrentTool), false)
    end
    local previousVisits = {gCurrentNode}
    while not (queue[1][#queue[1]][1] == target) do -- If last node of the path matches the target we have found a valid path.
        nodeName = queue[1][#queue[1]][1]
        knownNodes = Set(previousVisits )
        if (not knownNodes[nodeName]) then
            --print("nodeName: " .. nodeName)
            for i, currentPath in ipairs(gNodes[nodeName][2]) do
			checkPathReferences(currentPath)
                toolOptions = Set(currentPath[4])
                if (toolOptions[gCurrentTool]) then
                    path = {}
                    path = deepCopy(queue[1])
                    table.insert(path, {currentPath[1], currentPath[2], currentPath[3]}) --create path with additional node.
                    table.insert(queue, deepCopy(path)) -- insert amended path at the back of the queue.
                end
            end
        end
        table.remove(queue, 1) --remove the path we were looking at
        table.insert(previousVisits, nodeName)
		local next = next
        if next(queue) == nil then
            popup_message(0, "Error. No path found in searchTree from " .. gCurrentNode .. " to " .. target, false)
        end
    end
    print("Found path to " .. target)
    printTable(queue[1])
    return deepCopy(queue[1]) -- return the path in format {{nodeName1, movetype1, speed1}, {nodeName2, movetype2, speed2}, ...}
end

local filePathLog = "/root/AuboRobotWorkSpace/teachpendant/share/teachpendant/script/PositionsLog.aubo"

fileLog = io.open(filePathLog, 'w')
fileLog:write("start\n")
fileLog:close()
function savePose(name)
    local filepath = "/root/AuboRobotWorkSpace/teachpendant/share/teachpendant/script/PositionsLog.aubo"
    file = io.open(filepath, 'a')
    local waypoint = get_current_waypoint()
    local currentPose = waypoint.joint
    local currentPos = waypoint.pos
    local str = tostring(name) .. " -> \nFixedJoints("
    str = str .. (tostring(gNodes[name][1][1]) .. ", "..
    tostring(gNodes[name][1][2]) .. ", "..
    tostring(gNodes[name][1][3]) .. ", "..
    tostring(gNodes[name][1][4]) .. ", "..
    tostring(gNodes[name][1][5]) .. ", "..
    tostring(gNodes[name][1][6]))
    str = str .. ")\nActualJoints("
    str = str .. (tostring(currentPose["j1"]) .. ", "..
        tostring(currentPose["j2"]) .. ", "..
        tostring(currentPose["j3"]) .. ", "..
        tostring(currentPose["j4"]) .. ", "..
        tostring(currentPose["j5"]) .. ", "..
        tostring(currentPose["j6"]))
    str = str .. ")\nActualPose(" .. currentPos["x"] .. ", ".. currentPos["y"] .. ", ".. currentPos["z"]
    str = str .. ")\n"
    file:write(str)
    file:close()
end

function movePath(endNode, onEachMove) --move along path to node with name: endNode. execute onEachMove before each move
    if gSimulation then
        gCurrentNode = gNodes[endNode][1]
        return
    end
	local currentNodePose = gNodes[gCurrentNode][1]
    --[[Midlertidigt suspenderet ventende på en udvidning af checkpose så den medregner et offset. 
    if not checkPose(currentNodePose, 0.2) then
        popup_message(0, "Error. Robot not at currentNode pose in movePath", false)
        return
    end
    ]]
    local path = searchTree(endNode)
    if path == "alreadyAtPosition" then
        return
    end
    for i, node in ipairs(path) do
        print("Moving " .. node[2] .. "wise to " .. node[1] .." with speed " .. node[3])
	    init_global_move_profile()
        if onEachMove~= nil and onEachMove() == "cancel" then
            return "cancel"
        end
        if (gNodes[node[1]][1] == "variable") or (gNodes[node[1]][1] == nil) then
            popup_message(0, "Error. No pose found for node: " .. node[1] .. " in movePath.", false)
        end
        if gNodes[node[1]][3] == "none" then
            move(gNodes[node[1]][1], node[2], node[3], true)
            savePose(node[1])
        elseif gOffsetTable[gNodes[node[1]][3]] == nil then
			popup_message(0, "Error. No offfset reference found in movePath", false)
		else
            setOffset(gNodes[node[1]][3])
            move(gNodes[node[1]][1], node[2], node[3], true)
            savePose(node[1])
            init_global_move_profile()
        end
        gCurrentNode = node[1]
    end
end


---------------- section 7 - Matrix Manipulation and rotation -------------------

function dot(point1, point2)
    if not (#point1 == #point2) then
        popup_message(0, "Error. Points are of different length in dot", false)
    end
    local sum = 0
    for i = 1, #point1 do
        sum = sum + point1[i]*point2[i]
    end
    return sum
end

function checkMatrix(mat) -- returns true if matrix is valid.
    if next(mat) == nil then
        popup_message(0, "Error. Matrix empty in checkMatrix")
    end
    for i = 1, #mat do
        if (next(mat[i]) == nil) then
            popup_message(0, "Error. Matrix row empty in checkMatrix")
        end
        if (not (#mat[i] == #mat[1])) then
            return popup_message(0, "Error. Matrix invalid in checkMatrix", false)
        end
    end
end

function getColoumnOfMatrix(mat, coloumn)
    checkMatrix(mat)
    coloumn = coloumn or 1
    local coloumnList = {}
    for i = 1, #mat do
        table.insert(coloumnList, mat[i][coloumn])
    end
    return coloumnList
end

function rowToColoumn(vector)
    local newMat = {}
    for i=1, #vector do
        table.insert(newMat, {vector[i]})
    end
    return newMat
end

function matrixMultiply(mat1, mat2)
    checkMatrix(mat1)
    checkMatrix(mat2)
    if not (#mat1[1] == #mat2) then
        popup_message(0, "Error. Matrices incompatible in matrixMultiply", false)
    end
    local result = {}
    local resultRow = {}
    for i = 1, #mat1[1] do
        for j = 1, #mat2[1] do
            local mat2Coloumn = getColoumnOfMatrix(mat2, j)
            table.insert(resultRow, dot(mat1[i], mat2Coloumn))
        end
        table.insert(result, resultRow)
        resultRow = {}
    end
    return result
end

function rotatePointAboutAxis(point, axis, angle) -- point in {x,y,z} format, axis is a string: "x", "y" or "z", angle is measured in radians
    local newPoint
    if #point == 3 then
        local coloumnPoint = rowToColoumn(point)
        local rotationMatrix = {}
        if axis == "x" then
            rotationMatrix = {
                {1,0,0},
                {0, math.cos(angle), -math.sin(angle)},
                {0, math.sin(angle), math.cos(angle)}
            }
        elseif axis == "y" then
            rotationMatrix = {
                {math.cos(angle),0,math.sin(angle)},
                {0, 1, 0},
                {-math.sin(angle), 0, math.cos(angle)}
            }
        elseif axis == "z" then
            rotationMatrix = {
                {math.cos(angle),-math.sin(angle), 0},
                {math.sin(angle), math.cos(angle), 0},
                {0, 0, 1}
            }
        end
        newPoint = matrixMultiply(rotationMatrix, coloumnPoint)
        newPoint = getColoumnOfMatrix(newPoint, 1)
    else
        popup_message(0, "Error. Wrong length of point in rotatePointAboutAxis", false)
    end
    return newPoint
end